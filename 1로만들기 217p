x= int(input())

d= [0]* 30001

for i in range(2, x+1):

  d[i]= d[i-1]+1
  if i%2==0:
    d[i]= min(d[i], d[i//2]+1)
  if i%3==0:
    d[i]= min(d[i], d[i//3]+1)
  if i%5==0:
    d[i]= min(d[i], d[i//5]+1)

print(d[x])

1. 99p의 그리디 문제와 다르게 항상 나누는게 더 빠르지 않고 뺴기와 적절히 조합해야 더 빠르다.

2. (1)어떤 갑을 구하기 위해서 그것보다 작은 구조의 값들이 사용된다는 점에서 최적 부분구조가 성립한다.(각 문제는 작은 문제들을 조합해서 해결할 수 있다)
   (2)동일한 문제가 여러번 호출되므로 중복되는 부분 문제를 만족한다고 볼 수 있다.
   따라서 다이나믹 프로그래밍을 이용한다.
   
3. 상향식 패턴에 
