일단 n을 입력받기

놓을 수 없는 경우를 따져보자
1. 행이 같은경우
2. 열이 같은경우
3. 대각선이 같은경우

------

dfs로 계~~~속 순환시키기

row=[0,0,0,0,0]
row[a]=b에서 a는 행 b는 열
퀸을 [a,b]위치에 놓겠다

전제1 nxn의 체스판에서 퀸을 n개를 놓아야 함.
즉 각 행마다 퀸을 하나씩 놓아야 한다.
따라서 끝까지 가는게 아니라 조건을 만족하지 못하면
돌아와야 한다.

row는 체스판을 표기하는게 아니라 퀸의 위치를 표기하는 것이다

퀸끼리 서로 비교하는 것이다

####


n=int(input())

row=[0]*n ##row=[1,2,3,4]이면 퀸이 row[0]=1//(0,1) 0행일때 1열에 (1,2) 1행일때는 2열에....있다는 얘기
ans=0     #0행부터 내려가면서 퀸을 놓아가는 컨셉을 잘 기억해야한다.

def check(x):
  for i in range(x): #i는 x-1까지니까 x행과 x-1행까지의 값을 비교하겠다
    if row[i]==row[x] or abs(x-i)==abs(row[i]-row[x]):
      return False
  return True
    
def queen(x):
  global ans
  if x==n: ##다 왔으니까 결과값에 하나 추가해라
    ans+=1
    return
    
  else:
    for i in range(n): #어떤 열에 놓을지 경우를 다 따져봐야 하니까
      row[x]=i #열에 배정!
      if check(x):      
        queen(x+1)

queen(0)
print(ans)


#해야할 것: 어떤 좌표를 받아서 그 자리에 올 수 있는지 검사하는 함수=>인자를 어떻게 받지?=>좌표를 따로 필요는 없고 그냥 있는거이서 이용하면 돼
, 첫번쨰 행부터 검사할 행-1까지의 모든 행에 있는 퀸들을 검사하는거지
 
#n개의 퀸을 놓아야 한다 따라서 한행에는 하나의 퀸밖에 올 수 없다=>row를 이용해서 각 행에 퀸이 몇열에 있는지만 확인하면 됨
만약 2행에 놓고 3행 갔는데 막힌다 그럼 2행으로 돌아가서 2행의 다음 열을 해보는 것

row[a]=b라고 하면 좌표 a,b에 퀸이 있는 것이다. 일단 row[0]=0가 아니고 row=[0]*n

퀸의 개수가 n개가 될 때까지 반복할 반복문도 필요할듯=>재귀적으로 갈꺼라서 반복문은 필요 없어. dfs내에서 계속 반복해 나갈거야

x라는 매개변수가 의미하는 것은 지금 몇번째 행을 다루냐야. 한 행씩 살펴보면서 만족한다면 다음 행에 놓아보는거지

n번째인지 검사하는 것은 dfs함수의 어디에 넣어야 하나? is promising다음에?=>is promising을 거쳐야 하는건 맞는데 이렇게 거친 것들은
dfs(x+1)을 통해서 다음으로 넘어가니까 맨 앞에 놓으면 된다. n을 받을때 각 행열은 n개이고 인덱스는 0부터 n-1까지니까 dfs에서 n을 
받았다는 것은 모든 것을 이미 검사 했다는 뜻이다. 새로 한다는 뜻이 아니다.


