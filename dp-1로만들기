x=int(input())

d=[0 for _ in range(x+1)]  #dp의 각 인덱스의 의미는, 인덱스에 있는 수를 1 로 만드려면 몇번 연산하여야 하는지이다.

for i in range(2,x+1):
  d[i]=d[i-1]+1
  if i%3==0:
    d[i]=min(d[i],d[i//3]+1)
  if i%2==0:
    d[i]=min(d[i],d[i//2]+1)

print(d[x])

#문제의 최적해가 부분 문제들의 최적해로부터 구성됩니다.

"""
중복되는 부분 문제(Overlapping Subproblems)가 존재합니다:
숫자를 1로 만드는 과정에서 같은 숫자에 대해 여러 번 연산을 수행해야 하는 경우가 발생할 수 있습니다.
이러한 중복되는 부분 문제를 메모이제이션(memoization) 또는 테이블화(tabulation)를 통해 기록하고, 이미 계산된 결과를 재사용함으로써 전체 계산 시간을 줄일 수 있습니다.

최적 부분 구조(Optimal Substructure)가 존재합니다:
문제의 최적해가 부분 문제들의 최적해로부터 구성됩니다. 
각 단계에서 최소 연산 횟수를 선택하면 전체 문제의 최적해를 구할 수 있습니다. 이러한 성질을 활용하여 동적 계획법을 사용해 문제를 효율적으로 해결할 수 있습니다."""

dp는 bottom up과 top down모두 사용 가능 top down은 메모제이션 bottom up은 반복문 이용하는 것
dfs는 top down방식 이용하는 것.

여기에서는 dp테이블의 의미를 인덱스의 수를 1 로 만드려면 몇번 연산해야하는지이다. 이 몇번연산해야하는지는 부분최적의 합이다. 
